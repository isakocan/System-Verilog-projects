$date
	Thu Apr 17 19:07:35 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module datapath_tb_2b $end
$var reg 3 ! tb_ALUControl [2:0] $end
$var reg 1 " tb_Clk $end
$var reg 2 # tb_RegReadAddr1 [1:0] $end
$var reg 2 $ tb_RegReadAddr2 [1:0] $end
$var reg 2 % tb_RegWriteAddr [1:0] $end
$var reg 1 & tb_RegWriteEnable $end
$var reg 1 ' tb_Rst $end
$scope module dut $end
$var wire 3 ( ALUControl [2:0] $end
$var wire 1 " Clk $end
$var wire 2 ) RegReadAddr1 [1:0] $end
$var wire 2 * RegReadAddr2 [1:0] $end
$var wire 2 + RegWriteAddr [1:0] $end
$var wire 1 & RegWriteEnable $end
$var wire 1 ' Rst $end
$var wire 32 , rf_ReadData2 [31:0] $end
$var wire 32 - rf_ReadData1 [31:0] $end
$var wire 1 . alu_oVerflow $end
$var wire 32 / alu_Result [31:0] $end
$scope module alu_unit $end
$var wire 3 0 ALUControl [2:0] $end
$var wire 32 1 B_operand [31:0] $end
$var wire 1 . oVerflow $end
$var wire 32 2 xor_result [31:0] $end
$var wire 32 3 slt_result [31:0] $end
$var wire 32 4 and_result [31:0] $end
$var wire 32 5 adder_sum [31:0] $end
$var wire 1 6 adder_cout $end
$var wire 32 7 Result [31:0] $end
$var wire 1 8 Cin $end
$var wire 32 9 B [31:0] $end
$var wire 32 : A [31:0] $end
$var parameter 32 ; N $end
$scope module adder_unit $end
$var wire 32 < B [31:0] $end
$var wire 1 8 Cin $end
$var wire 32 = Sum [31:0] $end
$var wire 1 6 Cout $end
$var wire 32 > A [31:0] $end
$var parameter 32 ? N $end
$upscope $end
$scope module and_unit $end
$var wire 32 @ Result [31:0] $end
$var wire 32 A B [31:0] $end
$var wire 32 B A [31:0] $end
$var parameter 32 C N $end
$upscope $end
$scope module output_mux $end
$var wire 32 D In_AddResult [31:0] $end
$var wire 32 E In_AndResult [31:0] $end
$var wire 32 F In_SubResult [31:0] $end
$var wire 3 G Sel [2:0] $end
$var wire 32 H In_XorResult [31:0] $end
$var wire 32 I In_SltResult [31:0] $end
$var parameter 32 J N $end
$var reg 32 K Out [31:0] $end
$upscope $end
$scope module slt_unit $end
$var wire 1 . Overflow $end
$var wire 1 L Sum_MSB $end
$var wire 1 M slt_bit $end
$var wire 32 N SLT_Result [31:0] $end
$var parameter 32 O N $end
$upscope $end
$scope module xor_unit $end
$var wire 32 P Result [31:0] $end
$var wire 32 Q B [31:0] $end
$var wire 32 R A [31:0] $end
$var parameter 32 S N $end
$upscope $end
$upscope $end
$scope module rf_unit $end
$var wire 2 T addr1 [1:0] $end
$var wire 2 U addr2 [1:0] $end
$var wire 2 V addr3 [1:0] $end
$var wire 1 " clk $end
$var wire 32 W data1 [31:0] $end
$var wire 32 X data2 [31:0] $end
$var wire 32 Y data3 [31:0] $end
$var wire 1 ' rst $end
$var wire 1 & wr $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100000 S
b100000 O
b100000 J
b100000 C
b100000 ?
b100000 ;
$end
#0
$dumpvars
b0 Y
b10010001101000101011001111000 X
b10010001101000101011001111000 W
b1 V
b0 U
b0 T
b10010001101000101011001111000 R
b10010001101000101011001111000 Q
b0 P
b0 N
0M
0L
b0 K
b0 I
b0 H
b11 G
b0 F
b10010001101000101011001111000 E
b0 D
b10010001101000101011001111000 B
b10010001101000101011001111000 A
b10010001101000101011001111000 @
b10010001101000101011001111000 >
b0 =
b11101101110010111010100110000111 <
b10010001101000101011001111000 :
b10010001101000101011001111000 9
18
b0 7
16
b0 5
b10010001101000101011001111000 4
b0 3
b0 2
b11101101110010111010100110000111 1
b11 0
b0 /
0.
b10010001101000101011001111000 -
b10010001101000101011001111000 ,
b1 +
b0 *
b0 )
b11 (
0'
1&
b1 %
b0 $
b0 #
0"
b11 !
$end
#5000
1"
#10000
06
b1 3
b1 I
b1 N
1M
1L
08
b11111111111111111111111111111111 /
b11111111111111111111111111111111 7
b11111111111111111111111111111111 K
b11111111111111111111111111111111 Y
b0 1
b0 <
b11111111111111111111111111111111 2
b11111111111111111111111111111111 H
b11111111111111111111111111111111 P
b0 4
b0 @
b0 E
b11111111111111111111111111111111 5
b11111111111111111111111111111111 =
b11111111111111111111111111111111 D
b11111111111111111111111111111111 F
0"
b0 %
b0 +
b0 V
b0 !
b0 (
b0 0
b0 G
b0 ,
b0 9
b0 A
b0 Q
b0 X
b1 $
b1 *
b1 U
b11111111111111111111111111111111 -
b11111111111111111111111111111111 :
b11111111111111111111111111111111 >
b11111111111111111111111111111111 B
b11111111111111111111111111111111 R
b11111111111111111111111111111111 W
b10 #
b10 )
b10 T
1&
#15000
1"
#20000
b1 3
b1 I
b1 N
1M
1L
18
b11111111111111111111111111111111 /
b11111111111111111111111111111111 7
b11111111111111111111111111111111 K
b11111111111111111111111111111111 Y
b11111111111111111111111111111110 1
b11111111111111111111111111111110 <
b1 2
b1 H
b1 P
b11111111111111111111111111111111 5
b11111111111111111111111111111111 =
b11111111111111111111111111111111 D
b11111111111111111111111111111111 F
0"
b10 %
b10 +
b10 V
b1 !
b1 (
b1 0
b1 G
b1 ,
b1 9
b1 A
b1 Q
b1 X
b11 $
b11 *
b11 U
b0 -
b0 :
b0 >
b0 B
b0 R
b0 W
b1 #
b1 )
b1 T
1&
#25000
1"
#30000
b0 3
b0 I
b0 N
0M
0L
b1 1
b1 <
08
b0 /
b0 7
b0 K
b0 Y
b11111111111111111111111111111110 2
b11111111111111111111111111111110 H
b11111111111111111111111111111110 P
b1 4
b1 @
b1 E
b0 5
b0 =
b0 D
b0 F
16
0"
b11 %
b11 +
b11 V
b0 !
b0 (
b0 0
b0 G
b11111111111111111111111111111111 -
b11111111111111111111111111111111 :
b11111111111111111111111111111111 >
b11111111111111111111111111111111 B
b11111111111111111111111111111111 R
b11111111111111111111111111111111 W
b0 #
b0 )
b0 T
1&
#35000
1"
0&
#40000
0"
