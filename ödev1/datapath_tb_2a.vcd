$date
	Thu Apr 17 18:24:19 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module datapath_tb_2a $end
$var reg 3 ! tb_ALUControl [2:0] $end
$var reg 1 " tb_Clk $end
$var reg 2 # tb_RegReadAddr1 [1:0] $end
$var reg 2 $ tb_RegReadAddr2 [1:0] $end
$var reg 2 % tb_RegWriteAddr [1:0] $end
$var reg 1 & tb_RegWriteEnable $end
$var reg 1 ' tb_Rst $end
$scope module dut $end
$var wire 3 ( ALUControl [2:0] $end
$var wire 1 " Clk $end
$var wire 2 ) RegReadAddr1 [1:0] $end
$var wire 2 * RegReadAddr2 [1:0] $end
$var wire 2 + RegWriteAddr [1:0] $end
$var wire 1 & RegWriteEnable $end
$var wire 1 ' Rst $end
$var wire 32 , rf_ReadData2 [31:0] $end
$var wire 32 - rf_ReadData1 [31:0] $end
$var wire 1 . alu_oVerflow $end
$var wire 32 / alu_Result [31:0] $end
$scope module alu_unit $end
$var wire 3 0 ALUControl [2:0] $end
$var wire 32 1 B_operand [31:0] $end
$var wire 1 . oVerflow $end
$var wire 32 2 xor_result [31:0] $end
$var wire 32 3 slt_result [31:0] $end
$var wire 32 4 and_result [31:0] $end
$var wire 32 5 adder_sum [31:0] $end
$var wire 1 6 adder_cout $end
$var wire 32 7 Result [31:0] $end
$var wire 1 8 Cin $end
$var wire 32 9 B [31:0] $end
$var wire 32 : A [31:0] $end
$var parameter 32 ; N $end
$scope module adder_unit $end
$var wire 32 < B [31:0] $end
$var wire 1 8 Cin $end
$var wire 32 = Sum [31:0] $end
$var wire 1 6 Cout $end
$var wire 32 > A [31:0] $end
$var parameter 32 ? N $end
$upscope $end
$scope module and_unit $end
$var wire 32 @ Result [31:0] $end
$var wire 32 A B [31:0] $end
$var wire 32 B A [31:0] $end
$var parameter 32 C N $end
$upscope $end
$scope module output_mux $end
$var wire 32 D In_AddResult [31:0] $end
$var wire 32 E In_AndResult [31:0] $end
$var wire 32 F In_SubResult [31:0] $end
$var wire 3 G Sel [2:0] $end
$var wire 32 H In_XorResult [31:0] $end
$var wire 32 I In_SltResult [31:0] $end
$var parameter 32 J N $end
$var reg 32 K Out [31:0] $end
$upscope $end
$scope module slt_unit $end
$var wire 1 . Overflow $end
$var wire 1 L Sum_MSB $end
$var wire 1 M slt_bit $end
$var wire 32 N SLT_Result [31:0] $end
$var parameter 32 O N $end
$upscope $end
$scope module xor_unit $end
$var wire 32 P Result [31:0] $end
$var wire 32 Q B [31:0] $end
$var wire 32 R A [31:0] $end
$var parameter 32 S N $end
$upscope $end
$upscope $end
$scope module rf_unit $end
$var wire 2 T addr1 [1:0] $end
$var wire 2 U addr2 [1:0] $end
$var wire 2 V addr3 [1:0] $end
$var wire 1 " clk $end
$var wire 32 W data1 [31:0] $end
$var wire 32 X data2 [31:0] $end
$var wire 32 Y data3 [31:0] $end
$var wire 1 ' rst $end
$var wire 1 & wr $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100000 S
b100000 O
b100000 J
b100000 C
b100000 ?
b100000 ;
$end
#0
$dumpvars
b10011010101111001101111011101111 Y
b11111111111111111111111111111111 X
b10011010101111001101111011110000 W
b0 V
b10 U
b1 T
b10011010101111001101111011110000 R
b11111111111111111111111111111111 Q
b1100101010000110010000100001111 P
b1 N
1M
1L
b10011010101111001101111011101111 K
b1 I
b1100101010000110010000100001111 H
b0 G
b10011010101111001101111011101111 F
b10011010101111001101111011110000 E
b10011010101111001101111011101111 D
b10011010101111001101111011110000 B
b11111111111111111111111111111111 A
b10011010101111001101111011110000 @
b10011010101111001101111011110000 >
b10011010101111001101111011101111 =
b11111111111111111111111111111111 <
b10011010101111001101111011110000 :
b11111111111111111111111111111111 9
08
b10011010101111001101111011101111 7
16
b10011010101111001101111011101111 5
b10011010101111001101111011110000 4
b1 3
b1100101010000110010000100001111 2
b11111111111111111111111111111111 1
b0 0
b10011010101111001101111011101111 /
0.
b10011010101111001101111011110000 -
b11111111111111111111111111111111 ,
b0 +
b10 *
b1 )
b0 (
0'
1&
b0 %
b10 $
b1 #
0"
b0 !
$end
#5000
1"
#10000
b0 3
b0 I
b0 N
0M
0L
b1 /
b1 7
b1 K
b1 Y
b1 1
b1 <
b11111111111111111111111111111110 2
b11111111111111111111111111111110 H
b11111111111111111111111111111110 P
b1 4
b1 @
b1 E
b0 5
b0 =
b0 D
b0 F
0"
b1 %
b1 +
b1 V
b10 !
b10 (
b10 0
b10 G
b1 ,
b1 9
b1 A
b1 Q
b1 X
b11 $
b11 *
b11 U
b11111111111111111111111111111111 -
b11111111111111111111111111111111 :
b11111111111111111111111111111111 >
b11111111111111111111111111111111 B
b11111111111111111111111111111111 R
b11111111111111111111111111111111 W
b10 #
b10 )
b10 T
1&
#15000
1"
#20000
b0 3
b0 I
b0 N
0M
0L
b1100101010000110010000100010000 5
b1100101010000110010000100010000 =
b1100101010000110010000100010000 D
b1100101010000110010000100010000 F
18
b1100101010000110010000100010000 /
b1100101010000110010000100010000 7
b1100101010000110010000100010000 K
b1100101010000110010000100010000 Y
b1100101010000110010000100010000 2
b1100101010000110010000100010000 H
b1100101010000110010000100010000 P
b10011010101111001101111011101111 4
b10011010101111001101111011101111 @
b10011010101111001101111011101111 E
b1100101010000110010000100010000 1
b1100101010000110010000100010000 <
0"
b11 %
b11 +
b11 V
b11 !
b11 (
b11 0
b11 G
b10011010101111001101111011101111 ,
b10011010101111001101111011101111 9
b10011010101111001101111011101111 A
b10011010101111001101111011101111 Q
b10011010101111001101111011101111 X
b0 $
b0 *
b0 U
1&
#25000
1"
#30000
b1 3
b1 I
b1 N
1M
1L
b10011010101111001101111011110001 /
b10011010101111001101111011110001 7
b10011010101111001101111011110001 K
b10011010101111001101111011110001 Y
b10011010101111001101111011101111 1
b10011010101111001101111011101111 <
b1100101010000110010000100010001 2
b1100101010000110010000100010001 H
b1100101010000110010000100010001 P
b0 4
b0 @
b0 E
b10011010101111001101111011110001 5
b10011010101111001101111011110001 =
b10011010101111001101111011110001 D
b10011010101111001101111011110001 F
06
0"
b10 %
b10 +
b10 V
b1 !
b1 (
b1 0
b1 G
b1100101010000110010000100010000 ,
b1100101010000110010000100010000 9
b1100101010000110010000100010000 A
b1100101010000110010000100010000 Q
b1100101010000110010000100010000 X
b11 $
b11 *
b11 U
b1 -
b1 :
b1 >
b1 B
b1 R
b1 W
b1 #
b1 )
b1 T
1&
#35000
1"
#40000
0"
0&
